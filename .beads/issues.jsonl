{"id":"BID-1","title":"Implement full communication_iframe for cross-origin state sync","description":"The communication_iframe is currently a minimal stub that just prevents 404 errors. It needs to be fleshed out to properly handle cross-origin login state synchronization.\n\nThe iframe sits hidden on every page that includes `include.js` and should:\n\n1. **Detect existing sessions** - Check if user is already authenticated with the broker when page loads\n2. **Notify of login/logout** - Trigger `onlogout` callbacks on all open tabs when user logs out from broker or another site\n3. **Enable `onmatch` callback** - Fire `navigator.id.watch({ onmatch: ... })` when existing session matches\n\nCurrently located at: `browserid-broker/static/communication_iframe.html`\n\nReference: Original Persona used jschannel for the cross-origin messaging protocol.","acceptance_criteria":"- [ ] Communication iframe properly initializes jschannel connection with include.js\n- [ ] Existing broker session is detected on page load\n- [ ] Login events are broadcast to all tabs with include.js loaded\n- [ ] Logout events are broadcast to all tabs\n- [ ] `onmatch` callback fires when session exists","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-26T21:47:03.172494+01:00","updated_at":"2025-12-26T21:47:03.172494+01:00"}
{"id":"BID-2","title":"Port browserid communication_iframe with localStorage keypair model","description":"Adopt the original browserid architecture for the communication_iframe and related client-side code. This includes porting the localStorage keypair storage model instead of generating fresh keypairs each time.\n\n## Files to port (from static_resources.js communication_iframe.js bundle):\n\n### Core infrastructure\n- common/js/browserid.js - Core namespace\n- common/js/lib/jschannel.js - Already in include.js\n- common/js/lib/tinyscore.js - Utility library (underscore-like)\n- common/js/lib/hub.js - Event hub\n- common/js/lib/micrajax.js - XHR library\n- common/js/javascript-extensions.js - JS extensions\n- common/js/mediator.js - Mediator pattern\n- common/js/helpers.js - Helper functions\n- common/js/class.js - OOP helpers\n- common/js/xhr_transport.js - XHR transport\n\n### Modules\n- common/js/modules/module.js - Module base\n- common/js/modules/xhr.js - XHR module\n\n### Models\n- common/js/models/models.js - Models base\n- common/js/models/user-context.js - User context\n- common/js/models/network-context.js - Network context\n- common/js/models/rp_info.js - RP info\n- common/js/models/interaction_data.js - Interaction data\n\n### Core logic (need crypto updates for Ed25519)\n- common/js/storage.js - LocalStorage abstraction (24KB)\n- common/js/network.js - Network layer (22KB)\n- common/js/crypto-loader.js - Crypto loading\n- common/js/provisioning.js - Key provisioning\n- common/js/user.js - User management (60KB) - THE BIG ONE\n\n### Entry point\n- dialog/js/misc/internal_api.js - Internal API\n- communication_iframe/start.js - The actual iframe logic\n\n## Key architectural change\nOriginal uses jwcrypto with DSA/RSA. We use Ed25519 with Web Crypto API.\nNeed to update crypto-loader.js, provisioning.js, and parts of user.js.","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-26T22:46:58.034379+01:00","updated_at":"2025-12-26T22:46:58.034379+01:00"}
{"id":"BID-3","title":"Add integration tests for cryptographic assertion validation","description":"Test coverage audit revealed significant gaps in testing the integration between dialog.js (creates assertions) and auth_with_assertion endpoint (verifies assertions).\n\nThe audience mismatch bug (fixed in commit 0974443) was not caught because:\n1. Unit tests construct assertions correctly (don't use dialog.js)\n2. E2E tests use mock certificates with fake signatures\n3. auth_with_assertion tests only check error paths\n\nSee docs/test-coverage-audit.md for full analysis.","design":"## Implementation Approach\n\n### Priority 1: auth_with_assertion integration tests\nFile: `browserid-broker/tests/auth_with_assertion_test.rs`\n\nNeed to:\n1. Create test infrastructure to register mock primary IdPs with real keypairs\n2. Add tests for valid assertion creating session\n3. Add tests for wrong audience (the bug we fixed)\n4. Add tests for untrusted issuer rejection\n\n### Priority 2: cert_key round-trip tests\nFile: `browserid-broker/tests/cert_key_test.rs`\n\nNeed to:\n1. Verify certificate signature against broker's public key\n2. Full round-trip: cert_key → create assertion → verify assertion\n\n### Priority 3: E2E crypto validation\nEither modify mock IdP to use real keys, or add validation endpoint for E2E tests.\n\n### Priority 4: DNS verification tests\nFile: `browserid-broker/tests/verifier_dns_test.rs`\n\nFill in placeholder with mock DNS resolver tests.","acceptance_criteria":"- [ ] auth_with_assertion has tests with cryptographically valid assertions\n- [ ] auth_with_assertion tests verify audience validation works correctly\n- [ ] auth_with_assertion tests verify issuer authority checking\n- [ ] cert_key tests verify generated certificates are cryptographically valid\n- [ ] cert_key tests include round-trip (generate → use in assertion → verify)\n- [ ] DNS verification tests use mock resolver\n- [ ] All tests pass with `cargo test`","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-01T15:31:43.098347+01:00","updated_at":"2026-01-01T15:31:43.098347+01:00"}
{"id":"BID-4","title":"Fix email selection to use correct assertion source (primary IdP vs broker)","description":"When a user selects an existing email to sign in with, the dialog always calls the broker's cert_key endpoint, even for emails that were added via a primary IdP. This results in:\n\n```\n✗ Verification Failed\n{\n  \"status\": \"failure\", \n  \"reason\": \"Issuer 'id.sandmill.org' is not authorized (expected 'sandmill.org')\"\n}\n```\n\nThe bug is in `completeSignIn()` which unconditionally calls `generateCertificate()` (broker's cert_key). \n\nThe fix must implement the full decision tree from original browserid's `getAssertion()` (user.js:1287-1373) and `email_chosen` state handler (state.js:400-476).","design":"## Root Cause\n\n`completeSignIn()` in dialog.js always calls `generateCertificate()` which requests a cert from the broker. This ignores:\n1. Stored certificates from primary IdPs\n2. The addressInfo state (transition_no_password, transition_to_secondary, etc.)\n3. Authentication level requirements\n\n## Required Changes\n\nMust implement the exact logic from original browserid:\n\n### 1. getAssertion flow (user.js:1287-1373)\n\n```\nHas stored identity with private key?\n├── YES → Create assertion using stored cert/key\n└── NO → Get addressInfo\n    ├── type === \"primary\" → provisionPrimaryUser() → get cert from IdP\n    └── type === \"secondary\" → syncEmailKeypair() → get cert from broker\n```\n\n### 2. email_chosen state handling (state.js:400-476)\n\n```\nGet addressInfo from server\n├── state === \"known\" \u0026\u0026 cert valid → generate assertion\n├── state === \"transition_to_primary\" → verify with IdP\n├── type === \"primary\" (no cert) → provision from IdP\n├── state === \"transition_to_secondary\" → password + verify\n├── state === \"transition_no_password\" → set password screen\n├── state === \"unverified\" → re-verify email\n└── secondary known → check auth level → authenticate or generate\n```\n\n## Implementation\n\n1. Add `getStoredEmailKeypair(email)` function to retrieve stored cert/key\n2. Add `isCertExpired(cert)` function to check certificate validity\n3. Add `createAssertionFromStored(email, stored)` to use stored primary cert\n4. Replace direct `completeSignIn()` call with `handleEmailChosen()` that implements the full state machine\n5. Ensure `handlePrimaryIdP()` is called for primary emails without valid stored certs\n\n## Key Files\n- browserid-broker/static/dialog.js - main changes\n- Reference: ~/src/browserid/resources/static/common/js/user.js\n- Reference: ~/src/browserid/resources/static/dialog/js/misc/state.js","acceptance_criteria":"- [ ] Selecting a primary IdP email uses stored certificate (not broker's cert_key)\n- [ ] Expired primary certificates trigger re-provisioning with IdP\n- [ ] Secondary emails with state \"known\" get cert from broker\n- [ ] State \"transition_no_password\" shows set password screen\n- [ ] State \"transition_to_secondary\" requires password + verification\n- [ ] State \"unverified\" triggers re-verification\n- [ ] Authentication level is checked before issuing secondary certs\n- [ ] All state transitions match original browserid behavior\n- [ ] E2E test passes for primary IdP → select email → sign in flow","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-01T15:51:15.372959+01:00","updated_at":"2026-01-01T16:29:04.759179+01:00","closed_at":"2026-01-01T16:29:04.759179+01:00"}
